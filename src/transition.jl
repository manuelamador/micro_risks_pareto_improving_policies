
###########################################################
#  Transition methods
###########################################################


# Given an optimized path, update the path forward starting from the first distribution
# in path and update the total asset supply. 
# 
# Note: this function expects that path.pdf[1] contains the initial asset distribution.
function walk_forward!(path, h)
    @inbounds for i in eachindex(path)
        pdf = path.pdf[i]
        if i < lastindex(path)
            pdf1 = path.pdf[i + 1]
            pol = path.pol[i]
            iterate_pdf!(pdf1, pdf, h, pol)
        end 
        path.s[i] = asset_supply(h, pdf)
    end 
end 


# Given a path, a household and a terminal state, final_ss, compute the path of
# optimal values and policies using r, w, and transfer variables contained in
# path. 
#
# Modifies path in place to include the value function and policy functions
function walk_back!(path, h, final_ss)
    v0 = final_ss.v
    for i in reverse(eachindex(path))
        Aiyagari.optimize_one_period!(
            (v0, path.v[i], path.pol[i]), 
            h, 
            path.r[i], 
            path.w[i], 
            path.transfer[i]
        )
        v0 = path.v[i]
    end
end



# Preallocates a structarray for a transition of length path_length starting 
# from laissez_faire.
function prealloc_and_initialize_path(laissez_faire, path_length)
    path = StructArray(
        (
            r = laissez_faire.r, 
            w = laissez_faire.w,  # this should not change
            transfer = laissez_faire.transfer, 
            v = similar(laissez_faire.v), 
            pol = similar(laissez_faire.pol), 
            pdf = similar(laissez_faire.pdf),
            s = laissez_faire.s, 
            b = laissez_faire.b, 
            k = laissez_faire.k
        ) for _ in 1:path_length)
    path.pdf[1] .= laissez_faire.pdf  # initial distribution
    return path 
end 


# Solves from the transition path starting from laissze_faire to final where 
# k and b follow the paths of k_path and b_path. 
#
# Note that the value of k_path[1] and b_path[1] are ignored, and assumed to 
# equal to the laissez faire values.
# TODO: Maybe change this ^ 
function solve_transition(
    laissez_faire, final, k_path::AbstractArray, b_path::AbstractArray;
    init_r_path = nothing,
    residuals = similar(k_path), 
    kwargs...
)
    path_length = length(k_path)
    # Create a function that given index returns the corresponding values 
    # of (k, b) in the path. 
    f = (_, i) -> begin 
        if 1 < i <= path_length 
            b = b_path[i]
            k = k_path[i]
        elseif i == 1
            b = laissez_faire.b 
            k = laissez_faire.k
        else 
            b = final.b
            k = final.k
        end 
        return (k, b)
    end 

    return solve_transition(
        laissez_faire, 
        final;
        k_b_fun = f, 
        path_length,
        init_r_path, 
        residuals,
        kwargs... 
    )
end 


# Solves from the transition path starting from laissze_faire to final where 
# k and b follow the paths generated by k_b_fun.
# 
# The function k_b_fun takes an an input and interest rate r and an index i and 
# should return the corresponding a tuple (k, b) representing the value of k and 
# b in that period i given interest rate r.
function solve_transition(
    laissez_faire, final;
    k_b_fun, 
    path_length, 
    init_r_path = nothing,
    residuals = Vector{typeof(laissez_faire.r)}(undef, path_length), 
    kwargs...
)
    nlsolve_kwargs = merge(
        (
            ftol = 10^(-6), 
            show_trace = true, 
            method = :anderson, 
            m = 10, 
            iterations = 100,
            beta = -0.03  # adjustment parameter for the fixed point algorithm
        ), kwargs
    )

    t = get_t(laissez_faire)
    h = get_h(laissez_faire)
    n0 = laissez_faire.n
    
    # initializing the path 
    path = prealloc_and_initialize_path(laissez_faire, path_length) # and we start from laissez_faire
    # s_list will contain the path of savings consistent with k + b
    s_list = Vector{typeof(laissez_faire.r)}(undef, path_length)
        
    # precomputing some values 
    x = laissez_faire.y - (t.δ + laissez_faire.r) * laissez_faire.k
    min_t = minimum_feasible_transfer(h, laissez_faire.w) + eps()
    rmin = - t.δ + eps()         # minimum interest rate
    rmax = 1 / h.β - 1 - eps()   # maximum interest rate
    
    f! = @closure (residuals, r_list) -> begin
        kprime = final.k
        bprime = final.b
        sprime = final.s
        @inbounds for i in reverse(1:path_length)
            r = clamp(r_list[i], rmin, rmax)  # r should be within (rmin, rmax)
            k, b = k_b_fun(r, i)  # get the k, b according to r and period i

            # Get the total S, assign to s_list
            s = i > 1 ? k + b : laissez_faire.s
            s_list[i] = s
            # Use resource constraint to solve for aggregate c 
            c = get_y(t, k = k, n = n0) + (1 - t.δ) * k - kprime
            
            # Assign to path
            path.r[i] = r   
            path.b[i] = b
            path.k[i] = k            
            path.transfer[i] = max(c - x  + sprime - (1 + r) * s, min_t)
            
            # Before moving back one period, reassigned the prime variables
            bprime = b
            kprime = k
            sprime = s
        end 
        # Solve for the optimal policy backwards, and update path.v and path.pol
        walk_back!(path, h, final)
        # Update path.pdf and path.s by iterating forward
        walk_forward!(path, h)

        # All fields of path are now updated (except for path.w which is unchanged)

        # Compute the difference between the household saving and the market 
        # total savings. This is the error. 
        @inbounds for i in eachindex(path)
            residuals[i] = (path.s[i] - s_list[i]) / s_list[i]
        end
    end

    # Initial guess for the transfer sequence.
    if isnothing(init_r_path) 
        r_list = [laissez_faire.r for _ in 1:path_length]
    else 
        r_list = init_r_path
    end 

    # Look for a path of r that solves market clearing 
    nlsolve((F, x) -> f!(F, x), r_list; nlsolve_kwargs...)

    f!(residuals, path.r) # store the residuals 

    return (path = path, init = laissez_faire, final = final, residuals = residuals) 
end

